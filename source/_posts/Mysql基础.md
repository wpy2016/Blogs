title: Mysql基础
date: 2020-2-6 08:06:02
tags:

  - Mysql
  - 数据库
---
## Mysql基础

**三大范式**

1. 第一范式1NF：指关系模型中，对于添加的一个规范要求，所有的域都是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子项。如果实体中某个属性有多个值，必须拆分为不同的属性，在符合第一范式1NF表中，每个域值只能是实体的一个属性或一个属性的一部分。

   举例说明：

   ![img](https://github.com/wpy2016/Blogs/blob/master/imgs/mysql_base/mysql_base1.png?raw=true)

   在上面的表中，“家庭信息”和“学校信息”列均不满足原子性的要求，故不满足第一范式，调整如下：

   ![img](https://github.com/wpy2016/Blogs/blob/master/imgs/mysql_base/mysql_base2.png?raw=true)

   可见，调整后的每一列都是不可再分的，因此满足第一范式（1NF）；

2. 第二范式2NF：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖），第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。简而言之，第二范式就是在第一范式的基础上属性完全依赖于主键。

   **二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）**

   举例说明：

   ![img](https://github.com/wpy2016/Blogs/blob/master/imgs/mysql_base/mysql_base3.png?raw=true)

   在上图所示的情况中，同一个订单中可能包含不同的产品，因此主键必须是“订单号”和“产品号”联合组成，

   但可以发现，产品数量、产品折扣、产品价格与“订单号”和“产品号”都相关，但是订单金额和订单时间仅与“订单号”相关，与“产品号”无关，

   这样就不满足第二范式的要求，调整如下，需分成两个表：

    ![img](https://github.com/wpy2016/Blogs/blob/master/imgs/mysql_base/mysql_base4.png?raw=true) ![img](https://github.com/wpy2016/Blogs/blob/master/imgs/mysql_base/mysql_base5.png?raw=true)

3. 第三范式3NF：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）**需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关，间接相关的需要拆分，拆分后，一个表中不包含已在其他表中已包含的非主关键字信息**。

   举例说明：

   ![img](https://github.com/wpy2016/Blogs/blob/master/imgs/mysql_base/mysql_base6.png?raw=true)

   上表中，所有属性都完全依赖于学号，所以满足第二范式，但是“班主任性别”和“班主任年龄”直接依赖的是“班主任姓名”，

   而不是主键“学号”，所以需做如下调整：

   ![img](https://github.com/wpy2016/Blogs/blob/master/imgs/mysql_base/mysql_base7.png?raw=true) ![img](https://github.com/wpy2016/Blogs/blob/master/imgs/mysql_base/mysql_base8.png?raw=true)

**4、巴斯-科德范式（BCNF）**：对第二范式与第三范式中设计规范要求加强。所有非主属性对每一个候选键都是完全函数依赖； 所有的主属性对每一个不包含它的候选键，也是完全函数依赖；没有任何属性完全函数依赖于非候选键的任何一组属性。

要了解 BCNF 范式，那么先看这样一个问题：

若：

1. 某公司有若干个仓库；
2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。

那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？

答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
码：（管理员，物品名），（仓库名，物品名）
主属性：仓库名、管理员、物品名
非主属性：数量

 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。

基于此关系模式的关系（具体的数据）可能如图所示：

![img](https://github.com/wpy2016/Blogs/blob/master/imgs/mysql_base/mysql_base9.png?raw=true)



好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：

1. 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
2. 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。
3. 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。

从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是 ”好“ 的设计。

造成此问题的原因：存在着**主属性**对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。

解决办法就是要在 3NF 的基础上消除**主属性**对于码的部分与传递函数依赖。

仓库（仓库名，管理员）
库存（仓库名，物品名，数量）

这样，之前的插入异常，修改异常与删除异常的问题就被解决了。

